\documentclass[a4paper]{article}

\usepackage{titlesec}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage[margin=1.2in]{geometry}
\usepackage{subcaption}


\usepackage{amssymb,amsmath}

\usepackage[colorlinks=true,
            linkcolor=blue,
            urlcolor=pink]{hyperref}

\newcommand{\kora}{%
(\raisebox{0.5em}{\rotatebox{-45}{)}}$^{\circ}{\scriptscriptstyle\Box}^{\circ}$)\raisebox{0.5em}{\rotatebox{-45}{)}}\rotatebox{90}{)}\raisebox{0.2em}{\LARGE \_\hskip-.1em\textvisiblespace\hskip-.1em\_}
}

\title{Single Thread-Contained Dispatcher as Middleware with Command as Request}

\makeatletter
\renewcommand{\maketitle}{\bgroup\setlength{\parindent}{0pt}
    \begin{center}

        \textbf{\huge\@title} \\[12pt]


        \par\vspace{\baselineskip}
    \end{center}

\egroup}
\makeatother

\titleformat{\section}
{\large\bfseries}
{\thesection}
{0.5em}
{}

\lstset{
    frame=single
}

\begin{document}
\maketitle

\section{Abstract}%
\label{sec:abstract}

The analysis of this labs could be roughly summarised as:
make device-type-generalized thread safe executions with \textit{Command Pattern} while
maintaining growth-allowed, read-write-specified and dynamic threads sets with
\textit{Singleton Pattern}.

In this work, we implemented tasks \textbf{case 2} with \textbf{C++}. Problems
were deconstructed into two stages. Stage of the first was
required to wrap the device action from concrete characterised
intefaces to a more unified read-write-distinguishable command
object. Then threads with uniformed name of access method were poured into
queues as threads pool, with r/w accordingly. With this design,
an execution of a command will be covered by a
life cycles of a single thread.

\section{Introduction}%
\label{sec:introduction}

Implementing in a OOP language, we first extract the \textbf{Device} in
\underline{include/abstract\_devices.h}. This module is found crucial
in the manner of data-racing-avoiding design. Features of C++17\footnote{
\url{https://en.cppreference.com/w/cpp/thread/shared\_mutex}}
(best practice for RW lock nowadays with multiple readers and a single writer)
(14 and 11 also included)
are adopted in partial parts of this project\footnote{
\url{https://github.com/ro-n/design-pattern}}
including but not limited to
RAII\footnote{\url{https://en.cppreference.com/w/cpp/language/raii}} lock and RTTI\footnote{
\url{https://en.cppreference.com/w/cpp/language/dynamic\_cast}} (sounds a sign of poor design).
Considering implementaions of the \textbf{Device}, any of the devices resembling
\textbf{InternetCard} or \textbf{GPU} will expose thread safe interfaces.

Bridging in between the devices and the commands, \textbf{ReadCommand} and
\textbf{WriteCommand} are created for later types inferring with \textsl{dynamic\_cast}.
We first mount devices, then create concrete commands,
after which read-write-specified threads with \textbf{Command} member function \textsl{execute()}
will be pushed into a thread container correspondingly. We may try to stop the execution
following \textsl{Dispatcher::start()}, still the \textbf{Dispatcher} wait for all threads'exit, however.
The dispatch man not only maintain queue of commands and pools of threads but also
undertake responsibilities for threads spawning and converging.

\begin{figure}[h]
    \centering
    \begin{subfigure}{.4\textwidth}
    \begin{center}
    \includegraphics[width=0.85\textwidth]{./class_command__inherit__graph.png}
    \end{center}
    \subcaption{Command Inheritance}%
    \label{fig:command_inheritance}
    \end{subfigure}
    \centering
    \begin{subfigure}{.4\textwidth}
    \begin{center}
    \includegraphics[width=0.95\textwidth]{./class_device__inherit__graph.png}
    \end{center}
    \subcaption{Device Inheritance}%
    \label{fig:device_inheritance}
    \end{subfigure}
    \caption{Design of Abstract Command and Device}%
    \label{fig:design_abstract}
\end{figure}

\section{Model}%
\label{sec:model}

Basically our model could be covered by figure\ref{fig:design_abstract}
\footnote{Demo diagrams are fully generated by Doxygen at \url{http://www.doxygen.nl/}}, through
which\ref{fig:command_inheritance}
wrapped command are capable of being inferred of their types to push into queues maintain
by the dispatcher. Devices\ref{fig:device_inheritance}
describe the inner design (structure) of the hardware,
inside which we implement the shared read/write lock in case of
concurrenet reading and writing.

\begin{figure}[h]
    \centering
    \begin{subfigure}{.3\textwidth}
    \begin{center}
    \includegraphics[width=0.8\textwidth]{./class_dispatcher_a740a58c6547cdf33dc9323d486630ccb_icgraph.png}
    \end{center}
    \subcaption{Dispatcher in Main()}%
    \label{fig:dispatch_in_main}
    \end{subfigure}
    \centering
    \begin{subfigure}{.3\textwidth}
    \begin{center}
    \includegraphics[width=0.9\textwidth]{./class_dispatcher_a740a58c6547cdf33dc9323d486630ccb_cgraph.png}
    \end{center}
    \subcaption{Dispatcher Start}%
    \label{fig:dispatcher_start}
    \end{subfigure}
    \centering
    \begin{subfigure}{.3\textwidth}
    \begin{center}
    \includegraphics[width=0.9\textwidth]{./class_dispatcher_ae3c73ff1334bcdbc0b354fd6f89d1c27_icgraph.png}
    \end{center}
    \subcaption{Dispatcher Terminate}%
    \label{fig:dispatcher_terminate}
    \end{subfigure}

\end{figure}

As is illustrated in figure\ref{fig:dispatch_in_main} and figure\ref{fig:dispatcher_start},
at the main thread will the static class \textbf{Dispatcher} call to \textsl{execute()} directly
after the \textsl{start()}. Then comes the \textsl{stop()}\ref{fig:dispatcher_terminate},
through which the
dispatcher loops through the correspondent container (R/W in this) and try block the main
thread with \textsl{std::thread::join()}, through which solves the early-end issue (that
is, main thread exits earlier than the distributed work threads).

\section{Details}%
\label{sec:details}

In this section\ref{sec:details}, we hope to demostrate with Q\&A.

\begin{itemize}
    \item \texttt{By which means have we implemented the \textit{Command Pattern}?}
        First we implement \textbf{Command} with pure \textsl{virtual} functions
        as behaving like a preliminary interface. Then insert a tight-coupling
        class to provide the concrete command with certain types. The grad-level
        class do write the \textsl{execute()}.
    \item \texttt{By which means have we implemented the \textit{Singleton Pattern}?}
        The \textbf{Dispatcher} behaves the singleton. There roughly exists two ways
        for us to implement it in C++, which can be \textsl{static Dispatcher D; return D;}
        or converting all members to static. The latter was adopted.
    \item \texttt{How do we solve \textbf{case 2}?}
        Case 2 simply asks: more generalized, dynamic threads creating and removing
        which are solved by extraction of the abstraction of the device and
        two containers of threads respectively.
    \item \texttt{How do we implement the multi-reader lock?}
        We present the lock with the C++17 \textsl{shared\_mutex}, which provides
        advantages of mutual access in between users within and without the same
        interfaces for the same resources.
    \item \texttt{How to ensure that lock works?} Hard to tell. One should consider
        a concurrenet reading from the resources followed by a writing request and
        the results of reading should always be the same as long as control the
        write to be the last thread to run with a conditional variable. Since our project
        only logs, it's hard to check.
    \item \texttt{Any improvements of this design?}
        Sure, more dynamic features should be added to the dispatcher. The
        \textsl{Dispatcher::start()} is not a read thread safe loop, we can
        concatenate the queue with a new queue of commands or maintain
        a thread continuously pour the threads from commands queue into the pools.
    \item \texttt{Why the output be undefined?}
        Though \textsl{std::cout} is a thread safe method,
        the \textbf{stdout} is shared due to the outprint mechanism. One should
        search all and replace them with a logging functions with a global mutex.
\end{itemize}

\section{Conclustion}%
\label{sec:conclustion}

In this task, we implemented tasks mainly focused on solving ``command as object divided into threads''.
\textit{Command Pattern} and \textit{Singleton Pattern} were utilized for this design. Hopefully we've presented
our thoughts clearly.

\section{Appendix}%
\label{sec:appendix}

\begin{lstlisting}
mounting devices...
dispatch starting...
send in net card
write to gpu
sound card recording
write to ram
read from gpu
read from gpu
dispatch stopping...
read from ram
dispatch stopped
unmounting devices...
\end{lstlisting}

\end{document}
